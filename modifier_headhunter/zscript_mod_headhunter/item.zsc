Class DI_Headhunter_Item : Inventory
{
	DI_HeadHunter_Handler handler;

	DI_Monster mon;
	double headbottom, headtop, handler_headbottom, handler_headtop;
	bool changepos;

	override void AttachToOwner(Actor other)
	{
		Super.AttachToOwner(other);
		
		mon = DI_Monster(other);
		
		mon.health *= 1.25;
		mon.StartHealth = other.health;
	}
	
	void ChangeHeadPosition() //prevent height manipulation from bugging out headshot collision
	{
		headbottom = handler_headbottom;
		headtop = handler_headtop;
		
		if (headbottom == -1) //no hitbox defined in HEADHUNT, use default position
		{
			headbottom = mon.height * 0.75;
		}
		if (headtop == -1) //no hitbox defined in HEADHUNT, use default position
		{
			headtop = mon.height;
		}
		
		if (mon.default.height > 0)
		{
			double mult = (1.0 * mon.height) / (1.0 * mon.default.height);
			headbottom *= mult;
			headtop *= mult;
		}
	}
	
	override void DoEffect()
	{
		Super.DoEffect();
		
		if (mon.height != mon.default.height) {changepos = true;}
	}
	
	override void AbsorbDamage(int damage, Name damageType, out int newdamage, Actor inflictor, Actor source, int flags)
	{
		if (damage > 0)
		{
			if ((inflictor != source) && (inflictor is "DI_Projectile"))
			{
				let proj = DI_Projectile(inflictor);
				if (handler.CanHeadshot(proj.getclassname()) && !proj.di_notweapon)
				{
					if (changepos) {ChangeHeadPosition();} //save performance by only calling this when height manipulation is detected
					//console.printf("Projectile Position: %.1f\nMonster Bottom: %.1f\nMonster Top: %.1f", proj.Pos.Z, (mon.Pos.Z + headbottom), (mon.Pos.Z + headtop));
					if ((proj.Pos.Z >= (mon.Pos.Z + headbottom)) && (proj.Pos.Z <= (mon.Pos.Z + headtop)))
					{
						newdamage *= 1.3;
						for (int i = 0; i < 3; ++i)
						{
							proj.A_SpawnParticle("ffea34", SPF_FULLBRIGHT, 35, 8, 0, 0, 0, 0, random(-4, 4), random(-4, 4), random(0, 4), 0, 0, -0.33, 0.5);
						}
					}
				}
			}
		}
	}
}